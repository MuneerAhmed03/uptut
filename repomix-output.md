This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-13T13:43:29.128Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
src/
  config/
    db/
      prisma/
        migrations/
          20250107061355_init/
            migration.sql
          20250107131843_add_email_verification/
            migration.sql
          migration_lock.toml
        schema.prisma
        seed.sql
        seed.ts
      database.ts
    redis.ts
  controllers/
    analytics.controller.ts
    auth.controller.ts
    book.controller.ts
    borrow.controller.ts
    payment.controller.ts
    user.controller.ts
  middlewares/
    auth.middleware.ts
    cache.middleware.ts
    errorHandler.middleware.ts
    rate-limit.middleware.ts
    request-logger.middleware.ts
    validate.middleware.ts
  models/
    analytics.schema.ts
    auth.schema.ts
    book.schema.ts
    borrow.schema.ts
    payment.schema.ts
    user.schema.ts
  routes/
    analytics.routes.ts
    auth.routes.ts
    book.routes.ts
    borrow.routes.ts
    payment.routes.ts
    user.routes.ts
  services/
    analytics.service.ts
    auth.service.ts
    book.service.ts
    borrow.service.ts
    payment.service.ts
    scheduler.service.ts
    user.service.ts
  utils/
    email.ts
    logger.ts
  index.ts
.dockerignore
.env.example
.gitignore
docker-compose.yml
Dockerfile
package.json
README.md
tsconfig.json
```

# Files

## File: src/config/db/prisma/migrations/20250107061355_init/migration.sql
```sql
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'MEMBER');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'PAID', 'FAILED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "role" "UserRole" NOT NULL DEFAULT 'MEMBER',
    "isEmailVerified" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Book" (
    "id" TEXT NOT NULL,
    "isbn" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "totalCopies" INTEGER NOT NULL DEFAULT 1,
    "availableCopies" INTEGER NOT NULL DEFAULT 1,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Book_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Author" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "bio" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Author_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BorrowedBook" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "bookId" TEXT NOT NULL,
    "borrowedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "dueDate" TIMESTAMP(3) NOT NULL,
    "returnedAt" TIMESTAMP(3),

    CONSTRAINT "BorrowedBook_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Transaction" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "borrowedBookId" TEXT NOT NULL,
    "amount" DOUBLE PRECISION NOT NULL,
    "status" "PaymentStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Transaction_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AuthorsOnBooks" (
    "bookId" TEXT NOT NULL,
    "authorId" TEXT NOT NULL,

    CONSTRAINT "AuthorsOnBooks_pkey" PRIMARY KEY ("bookId","authorId")
);

-- CreateTable
CREATE TABLE "CategoriesOnBooks" (
    "bookId" TEXT NOT NULL,
    "categoryId" TEXT NOT NULL,

    CONSTRAINT "CategoriesOnBooks_pkey" PRIMARY KEY ("bookId","categoryId")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Book_isbn_key" ON "Book"("isbn");

-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Transaction_borrowedBookId_key" ON "Transaction"("borrowedBookId");

-- AddForeignKey
ALTER TABLE "BorrowedBook" ADD CONSTRAINT "BorrowedBook_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BorrowedBook" ADD CONSTRAINT "BorrowedBook_bookId_fkey" FOREIGN KEY ("bookId") REFERENCES "Book"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Transaction" ADD CONSTRAINT "Transaction_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Transaction" ADD CONSTRAINT "Transaction_borrowedBookId_fkey" FOREIGN KEY ("borrowedBookId") REFERENCES "BorrowedBook"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AuthorsOnBooks" ADD CONSTRAINT "AuthorsOnBooks_bookId_fkey" FOREIGN KEY ("bookId") REFERENCES "Book"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AuthorsOnBooks" ADD CONSTRAINT "AuthorsOnBooks_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "Author"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CategoriesOnBooks" ADD CONSTRAINT "CategoriesOnBooks_bookId_fkey" FOREIGN KEY ("bookId") REFERENCES "Book"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CategoriesOnBooks" ADD CONSTRAINT "CategoriesOnBooks_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
```

## File: src/config/db/prisma/migrations/20250107131843_add_email_verification/migration.sql
```sql
-- CreateTable
CREATE TABLE "EmailVerificationToken" (
    "id" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "EmailVerificationToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "EmailVerificationToken_token_key" ON "EmailVerificationToken"("token");

-- AddForeignKey
ALTER TABLE "EmailVerificationToken" ADD CONSTRAINT "EmailVerificationToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
```

## File: src/config/db/prisma/migrations/migration_lock.toml
```toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
```

## File: src/config/db/prisma/schema.prisma
```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String         @id @default(uuid())
  email            String         @unique
  password         String
  firstName        String
  lastName         String
  role             UserRole       @default(MEMBER)
  isEmailVerified  Boolean        @default(false)
  isActive         Boolean        @default(true)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  deletedAt        DateTime?
  borrowedBooks    BorrowedBook[]
  transactions     Transaction[]
  verificationTokens EmailVerificationToken[]
}

model Book {
  id            String         @id @default(uuid())
  isbn          String         @unique
  title         String
  description   String?
  totalCopies   Int           @default(1)
  availableCopies Int         @default(1)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?
  borrowedBooks BorrowedBook[]
  categories    CategoriesOnBooks[]
  authors       AuthorsOnBooks[]
}

model Author {
  id        String           @id @default(uuid())
  name      String
  bio       String?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  books     AuthorsOnBooks[]
}

model Category {
  id        String             @id @default(uuid())
  name      String            @unique
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  books     CategoriesOnBooks[]
}

model BorrowedBook {
  id         String     @id @default(uuid())
  userId     String
  bookId     String
  borrowedAt DateTime   @default(now())
  dueDate    DateTime
  returnedAt DateTime?
  user       User       @relation(fields: [userId], references: [id])
  book       Book       @relation(fields: [bookId], references: [id])
  fine       Transaction?
}

model Transaction {
  id             String       @id @default(uuid())
  userId         String
  borrowedBookId String      @unique
  amount         Float
  status         PaymentStatus @default(PENDING)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User         @relation(fields: [userId], references: [id])
  borrowedBook   BorrowedBook @relation(fields: [borrowedBookId], references: [id])
}

model AuthorsOnBooks {
  bookId    String
  authorId  String
  book      Book    @relation(fields: [bookId], references: [id])
  author    Author  @relation(fields: [authorId], references: [id])

  @@id([bookId, authorId])
}

model CategoriesOnBooks {
  bookId     String
  categoryId String
  book       Book     @relation(fields: [bookId], references: [id])
  category   Category @relation(fields: [categoryId], references: [id])

  @@id([bookId, categoryId])
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  expiresAt DateTime
  createdAt DateTime @default(now())
}

enum UserRole {
  ADMIN
  MEMBER
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
}
```

## File: src/config/db/prisma/seed.sql
```sql
-- Users
INSERT INTO "User" (id, email, password, "firstName", "lastName", role, "isEmailVerified", "isActive", "createdAt", "updatedAt")
VALUES
  ('1a2b3c4d-5e6f-7g8h-9i0j-1k2l3m4n5o6p', 'admin@library.com', '$2a$10$6lA7Tkv0gOO5ILpR.pX1XeGHmGUqnzL6bB2PS1F2QOv6IsZiv1Aqe', 'Admin', 'User', 'ADMIN', true, true, NOW(), NOW()),
  ('2b3c4d5e-6f7g-8h9i-0j1k-2l3m4n5o6p7q', 'member@library.com', '$2a$10$6lA7Tkv0gOO5ILpR.pX1XeGHmGUqnzL6bB2PS1F2QOv6IsZiv1Aqe', 'Regular', 'Member', 'MEMBER', true, true, NOW(), NOW()),
  ('3c4d5e6f-7g8h-9i0j-1k2l-3m4n5o6p7q8r', 'john.doe@example.com', '$2a$10$6lA7Tkv0gOO5ILpR.pX1XeGHmGUqnzL6bB2PS1F2QOv6IsZiv1Aqe', 'John', 'Doe', 'MEMBER', true, true, NOW(), NOW());

-- Authors
INSERT INTO "Author" (id, name, bio, "createdAt", "updatedAt")
VALUES
  ('1d2e3f4g-5h6i-7j8k-9l0m-1n2o3p4q5r6s', 'George Orwell', 'English novelist and essayist', NOW(), NOW()),
  ('2e3f4g5h-6i7j-8k9l-0m1n-2o3p4q5r6s7t', 'Jane Austen', 'English novelist known for romantic fiction', NOW(), NOW()),
  ('3f4g5h6i-7j8k-9l0m-1n2o-3p4q5r6s7t8u', 'J.K. Rowling', 'British author best known for Harry Potter series', NOW(), NOW());

-- Categories
INSERT INTO "Category" (id, name, "createdAt", "updatedAt")
VALUES
  ('1g2h3i4j-5k6l-7m8n-9o0p-1q2r3s4t5u6v', 'Fiction', NOW(), NOW()),
  ('2h3i4j5k-6l7m-8n9o-0p1q-2r3s4t5u6v7w', 'Science Fiction', NOW(), NOW()),
  ('3i4j5k6l-7m8n-9o0p-1q2r-3s4t5u6v7w8x', 'Romance', NOW(), NOW()),
  ('4j5k6l7m-8n9o-0p1q-2r3s-4t5u6v7w8x9y', 'Fantasy', NOW(), NOW());

-- Books
INSERT INTO "Book" (id, isbn, title, description, "totalCopies", "availableCopies", "createdAt", "updatedAt")
VALUES
  ('1j2k3l4m-5n6o-7p8q-9r0s-1t2u3v4w5x6y', '9780451524935', '1984', 'A dystopian novel by George Orwell', 5, 3, NOW(), NOW()),
  ('2k3l4m5n-6o7p-8q9r-0s1t-2u3v4w5x6y7z', '9780141439518', 'Pride and Prejudice', 'A romantic novel by Jane Austen', 3, 2, NOW(), NOW()),
  ('3l4m5n6o-7p8q-9r0s-1t2u-3v4w5x6y7z8a', '9780439708180', 'Harry Potter and the Sorcerer''s Stone', 'First book in the Harry Potter series', 4, 2, NOW(), NOW()),
  ('4m5n6o7p-8q9r-0s1t-2u3v-4w5x6y7z8a9b', '9780141187761', 'Animal Farm', 'An allegorical novella by George Orwell', 3, 3, NOW(), NOW());

-- AuthorsOnBooks
INSERT INTO "AuthorsOnBooks" ("bookId", "authorId")
VALUES
  ('1j2k3l4m-5n6o-7p8q-9r0s-1t2u3v4w5x6y', '1d2e3f4g-5h6i-7j8k-9l0m-1n2o3p4q5r6s'),
  ('2k3l4m5n-6o7p-8q9r-0s1t-2u3v4w5x6y7z', '2e3f4g5h-6i7j-8k9l-0m1n-2o3p4q5r6s7t'),
  ('3l4m5n6o-7p8q-9r0s-1t2u-3v4w5x6y7z8a', '3f4g5h6i-7j8k-9l0m-1n2o-3p4q5r6s7t8u'),
  ('4m5n6o7p-8q9r-0s1t-2u3v-4w5x6y7z8a9b', '1d2e3f4g-5h6i-7j8k-9l0m-1n2o3p4q5r6s');

-- CategoriesOnBooks
INSERT INTO "CategoriesOnBooks" ("bookId", "categoryId")
VALUES
  ('1j2k3l4m-5n6o-7p8q-9r0s-1t2u3v4w5x6y', '2h3i4j5k-6l7m-8n9o-0p1q-2r3s4t5u6v7w'),
  ('2k3l4m5n-6o7p-8q9r-0s1t-2u3v4w5x6y7z', '3i4j5k6l-7m8n-9o0p-1q2r-3s4t5u6v7w8x'),
  ('3l4m5n6o-7p8q-9r0s-1t2u-3v4w5x6y7z8a', '4j5k6l7m-8n9o-0p1q-2r3s-4t5u6v7w8x9y'),
  ('4m5n6o7p-8q9r-0s1t-2u3v-4w5x6y7z8a9b', '1g2h3i4j-5k6l-7m8n-9o0p-1q2r3s4t5u6v');

-- BorrowedBooks (some returned, some active, some overdue)
INSERT INTO "BorrowedBook" (id, "userId", "bookId", "borrowedAt", "dueDate", "returnedAt")
VALUES
  ('1m2n3o4p-5q6r-7s8t-9u0v-1w2x3y4z5a6b', '2b3c4d5e-6f7g-8h9i-0j1k-2l3m4n5o6p7q', '1j2k3l4m-5n6o-7p8q-9r0s-1t2u3v4w5x6y', NOW() - INTERVAL '30 days', NOW() - INTERVAL '16 days', NOW() - INTERVAL '15 days'),
  ('2n3o4p5q-6r7s-8t9u-0v1w-2x3y4z5a6b7c', '3c4d5e6f-7g8h-9i0j-1k2l-3m4n5o6p7q8r', '2k3l4m5n-6o7p-8q9r-0s1t-2u3v4w5x6y7z', NOW() - INTERVAL '10 days', NOW() + INTERVAL '4 days', NULL),
  ('3o4p5q6r-7s8t-9u0v-1w2x-3y4z5a6b7c8d', '2b3c4d5e-6f7g-8h9i-0j1k-2l3m4n5o6p7q', '3l4m5n6o-7p8q-9r0s-1t2u-3v4w5x6y7z8a', NOW() - INTERVAL '20 days', NOW() - INTERVAL '6 days', NULL);

-- Transactions (fines for overdue books)
INSERT INTO "Transaction" (id, "userId", "borrowedBookId", amount, status, "createdAt", "updatedAt")
VALUES
  ('1p2q3r4s-5t6u-7v8w-9x0y-1z2a3b4c5d6e', '2b3c4d5e-6f7g-8h9i-0j1k-2l3m4n5o6p7q', '3o4p5q6r-7s8t-9u0v-1w2x-3y4z5a6b7c8d', 10.50, 'PENDING', NOW(), NOW());
```

## File: src/config/db/prisma/seed.ts
```typescript
import { PrismaClient, UserRole } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  try {
    const adminPassword = await bcrypt.hash("admin123", 10);
    const memberPassword = await bcrypt.hash("member123", 10);

    const admin = await prisma.user.upsert({
      where: { email: "admin@library.com" },
      update: {},
      create: {
        email: "admin@library.com",
        password: adminPassword,
        firstName: "Admin",
        lastName: "User",
        role: UserRole.ADMIN,
        isEmailVerified: true,
        isActive: true,
      },
    });

    const member = await prisma.user.upsert({
      where: { email: "member@library.com" },
      update: {},
      create: {
        email: "member@library.com",
        password: memberPassword,
        firstName: "Regular",
        lastName: "Member",
        role: UserRole.MEMBER,
        isEmailVerified: true,
        isActive: true,
      },
    });

    const johnDoe = await prisma.user.upsert({
      where: { email: "john.doe@example.com" },
      update: {},
      create: {
        email: "john.doe@example.com",
        password: memberPassword,
        firstName: "John",
        lastName: "Doe",
        role: UserRole.MEMBER,
        isEmailVerified: true,
        isActive: true,
      },
    });

    const georgeOrwell = await prisma.author.upsert({
      where: { id: "1d2e3f4g-5h6i-7j8k-9l0m-1n2o3p4q5r6s" },
      update: {},
      create: {
        name: "George Orwell",
        bio: "English novelist and essayist",
      },
    });

    const janeAusten = await prisma.author.upsert({
      where: { id: "2e3f4g5h-6i7j-8k9l-0m1n-2o3p4q5r6s7t" },
      update: {},
      create: {
        name: "Jane Austen",
        bio: "English novelist known for romantic fiction",
      },
    });

    const jkRowling = await prisma.author.upsert({
      where: { id: "3f4g5h6i-7j8k-9l0m-1n2o-3p4q5r6s7t8u" },
      update: {},
      create: {
        name: "J.K. Rowling",
        bio: "British author best known for Harry Potter series",
      },
    });

    const fiction = await prisma.category.upsert({
      where: { name: "Fiction" },
      update: {},
      create: { name: "Fiction" },
    });

    const sciFi = await prisma.category.upsert({
      where: { name: "Science Fiction" },
      update: {},
      create: { name: "Science Fiction" },
    });

    const romance = await prisma.category.upsert({
      where: { name: "Romance" },
      update: {},
      create: { name: "Romance" },
    });

    const fantasy = await prisma.category.upsert({
      where: { name: "Fantasy" },
      update: {},
      create: { name: "Fantasy" },
    });

    const book1984 = await prisma.book.upsert({
      where: { isbn: "9780451524935" },
      update: {},
      create: {
        isbn: "9780451524935",
        title: "1984",
        description: "A dystopian novel by George Orwell",
        totalCopies: 5,
        availableCopies: 3,
        authors: {
          create: {
            author: {
              connect: { id: georgeOrwell.id },
            },
          },
        },
        categories: {
          create: {
            category: {
              connect: { id: sciFi.id },
            },
          },
        },
      },
    });

    const prideAndPrejudice = await prisma.book.upsert({
      where: { isbn: "9780141439518" },
      update: {},
      create: {
        isbn: "9780141439518",
        title: "Pride and Prejudice",
        description: "A romantic novel by Jane Austen",
        totalCopies: 3,
        availableCopies: 2,
        authors: {
          create: {
            author: {
              connect: { id: janeAusten.id },
            },
          },
        },
        categories: {
          create: {
            category: {
              connect: { id: romance.id },
            },
          },
        },
      },
    });

    const harryPotter = await prisma.book.upsert({
      where: { isbn: "9780439708180" },
      update: {},
      create: {
        isbn: "9780439708180",
        title: "Harry Potter and the Sorcerer's Stone",
        description: "First book in the Harry Potter series",
        totalCopies: 4,
        availableCopies: 2,
        authors: {
          create: {
            author: {
              connect: { id: jkRowling.id },
            },
          },
        },
        categories: {
          create: {
            category: {
              connect: { id: fantasy.id },
            },
          },
        },
      },
    });

    const returnedBorrow = await prisma.borrowedBook.create({
      data: {
        userId: member.id,
        bookId: book1984.id,
        borrowedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
        dueDate: new Date(Date.now() - 16 * 24 * 60 * 60 * 1000), // 16 days ago
        returnedAt: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000), // 15 days ago
      },
    });

    const activeBorrow = await prisma.borrowedBook.create({
      data: {
        userId: johnDoe.id,
        bookId: prideAndPrejudice.id,
        borrowedAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000), // 10 days ago
        dueDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000), // due in 4 days
      },
    });

    const overdueBorrow = await prisma.borrowedBook.create({
      data: {
        userId: member.id,
        bookId: harryPotter.id,
        borrowedAt: new Date(Date.now() - 20 * 24 * 60 * 60 * 1000), // 20 days ago
        dueDate: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000), // 6 days overdue
      },
    });

    await prisma.transaction.create({
      data: {
        userId: member.id,
        borrowedBookId: overdueBorrow.id,
        amount: 10.5,
        status: "PENDING",
      },
    });

    console.log("Database has been seeded. 🌱");
  } catch (error) {
    console.error("Error seeding database:", error);
    throw error;
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

## File: src/config/db/database.ts
```typescript
import { PrismaClient } from ".prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

class Database {
  private static instance: Database;
  private _prisma: PrismaClient;

  private constructor() {
    this._prisma =
      globalThis.prisma ||
      new PrismaClient({
        log: ["query", "error", "warn"],
      });

    if (process.env.NODE_ENV === "development") {
      globalThis.prisma = this._prisma;
    }
  }

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  get prisma(): PrismaClient {
    return this._prisma;
  }

  async connect(): Promise<void> {
    try {
      await this._prisma.$connect();
      console.log("📦 Database connected successfully");
    } catch (error) {
      console.error("Database connection error:", error);
      process.exit(1);
    }
  }

  async disconnect(): Promise<void> {
    await this._prisma.$disconnect();
    console.log("📦 Database disconnected successfully");
  }
}

export const db = Database.getInstance();
export const prisma = db.prisma;
```

## File: src/config/redis.ts
```typescript
import { createClient } from "redis";
import { logger } from "../utils/logger";

const redisClient = createClient({
  url: process.env.REDIS_URL,
});

redisClient.on("error", (err) => {
  logger.error("Redis Client Error:", err);
});

redisClient.on("connect", () => {
  logger.info("Redis Client Connected");
});

export default redisClient;
```

## File: src/controllers/analytics.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { AnalyticsService } from "../services/analytics.service";
import {
  dateRangeSchema,
  analyticsQuerySchema,
} from "../models/analytics.schema";

const analyticsService = new AnalyticsService();

export const getMostBorrowedBooks = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedQuery = analyticsQuerySchema.parse(req.query);
    const books = await analyticsService.getMostBorrowedBooks(
      validatedQuery.limit,
    );

    res.json({
      status: "success",
      data: books,
    });
  } catch (error) {
    next(error);
  }
};

export const getMonthlyReport = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = dateRangeSchema.parse(req.query);
    const startDate = new Date(validatedData.startDate);
    const endDate = new Date(validatedData.endDate);

    const report = await analyticsService.getMonthlyReport(startDate, endDate);

    res.json({
      status: "success",
      data: report,
    });
  } catch (error) {
    next(error);
  }
};

export const getOverdueStats = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const stats = await analyticsService.getOverdueStats();

    res.json({
      status: "success",
      data: stats,
    });
  } catch (error) {
    next(error);
  }
};
```

## File: src/controllers/auth.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { AuthService } from "../services/auth.service";
import {
  loginSchema,
  registerSchema,
  emailVerificationSchema,
  passwordResetRequestSchema,
} from "../models/auth.schema";
import { AppError } from "../middlewares/errorHandler.middleware";

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  login = async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    try {
      const validatedData = loginSchema.parse({ body: req.body });
      const result = await this.authService.login(validatedData.body);
      res.json(result);
    } catch (error) {
      next(error);
    }
  };

  register = async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    try {
      const validatedData = registerSchema.parse({
        body: req.body,
      });
      const user = await this.authService.register(validatedData.body);
      res.status(201).json({
        message:
          "Registration successful. Please check your email to verify your account.",
        user,
      });
    } catch (error) {
      next(error);
    }
  };

  verifyEmail = async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    try {
      const validatedData = emailVerificationSchema.parse(req.query);
      const token = validatedData.token;
      if (!token || typeof token !== "string") {
        throw new AppError(400, "Verification token is required");
      }
      await this.authService.verifyEmail(token);
      res.json({ message: "Email verified successfully" });
    } catch (error) {
      next(error);
    }
  };

  resendVerificationEmail = async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    try {
      const validatedData = passwordResetRequestSchema.parse(req.body);
      const email = validatedData.email;
      if (!email) {
        throw new AppError(400, "Email is required");
      }
      await this.authService.resendVerificationEmail(email);
      res.json({ message: "Verification email sent successfully" });
    } catch (error) {
      next(error);
    }
  };
}
```

## File: src/controllers/book.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { BookService } from "../services/book.service";
import {
  createBookSchema,
  updateBookSchema,
  searchBooksSchema,
  deleteBookSchema,
} from "../models/book.schema";

const bookService = new BookService();

export const createBook = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = createBookSchema.parse(req.body);
    const book = await bookService.createBook(validatedData);

    res.status(201).json({
      status: "success",
      data: book,
    });
  } catch (error) {
    next(error);
  }
};

export const updateBook = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const { id } = req.params;
    const validatedData = updateBookSchema.parse(req.body);
    const book = await bookService.updateBook(id, validatedData);

    res.json({
      status: "success",
      data: book,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteBook = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = deleteBookSchema.parse(req.params);
    await bookService.deleteBook(validatedData.isbn);

    res.json({
      status: "success",
      message: "Book deleted successfully",
    });
  } catch (error) {
    next(error);
  }
};

export const searchBooks = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = searchBooksSchema.parse(req.query);
    const result = await bookService.findBooks({
      search: validatedData.query,
      categoryIds: validatedData.category
        ? [validatedData.category]
        : undefined,
      authorIds: validatedData.author ? [validatedData.author] : undefined,
      available: validatedData.available,
      skip: (validatedData.page - 1) * validatedData.limit,
      take: validatedData.limit,
    });

    res.json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const getBookDetails = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const { isbn } = req.params;
    const book = await bookService.findBookById(isbn);

    if (!book) {
      return res.status(404).json({
        status: "error",
        message: "Book not found",
      });
    }

    res.json({
      status: "success",
      data: book,
    });
  } catch (error) {
    next(error);
  }
};
```

## File: src/controllers/borrow.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { BorrowService } from "../services/borrow.service";
import { borrowBookSchema, borrowQuerySchema } from "../models/borrow.schema";
import { logger } from "../utils/logger";

const borrowService = new BorrowService();

export const borrowBook = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = borrowBookSchema.parse(req.body);
    const userId = req.user!.id;

    const result = await borrowService.borrowBook(userId, validatedData.bookId);

    res.status(201).json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const returnBook = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const { id: bookId } = req.params;
    const userId = req.user!.id;

    const result = await borrowService.returnBook(userId, bookId);

    res.json({
      status: "success",
      message: "Book returned successfully",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const getBorrowingHistory = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    const validatedQuery = borrowQuerySchema.parse(req.query);

    const result = await borrowService.getUserBorrows(userId, {
      status: validatedQuery.status,
      skip: (validatedQuery.page - 1) * validatedQuery.limit,
      take: validatedQuery.limit,
    });

    res.json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const sendDueReminders = async () => {
  try {
    const remindersSent = await borrowService.sendDueReminders();
    return remindersSent;
  } catch (error) {
    logger.error("Error sending due reminders:", error);
    throw error;
  }
};
```

## File: src/controllers/payment.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { PaymentService } from "../services/payment.service";
import { payFineSchema, paymentQuerySchema } from "../models/payment.schema";

const paymentService = new PaymentService();

export const getFines = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    const result = await paymentService.getFines(userId);

    res.json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const payFine = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData = payFineSchema.parse(req.body);
    const userId = req.user!.id;

    const result = await paymentService.payFine(
      userId,
      validatedData.transactionId,
      validatedData.paymentMethod,
    );

    res.json({
      status: "success",
      message: "Fine paid successfully",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const getPaymentHistory = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    const validatedQuery = paymentQuerySchema.parse(req.query);

    const result = await paymentService.getPaymentHistory(
      userId,
      validatedQuery.status,
    );

    res.json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

export const generateInvoice = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const { transactionId } = req.params;
    const userId = req.user!.id;

    const invoice = await paymentService.generateInvoice(userId, transactionId);

    res.json({
      status: "success",
      data: invoice,
    });
  } catch (error) {
    next(error);
  }
};
```

## File: src/controllers/user.controller.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { UserService } from "../services/user.service";
import {
  updateProfileSchema,
  updateUserRoleSchema,
} from "../models/user.schema";

const userService = new UserService();

export const getProfile = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    const user = await userService.getProfile(userId);

    res.json({
      status: "success",
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

export const updateProfile = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    const validatedData = updateProfileSchema.parse(req.body);
    const user = await userService.updateProfile(userId, validatedData);

    res.json({
      status: "success",
      message: "Profile updated successfully",
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

export const deactivateAccount = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user!.id;
    await userService.deactivateAccount(userId);

    res.json({
      status: "success",
      message: "Account deactivated successfully",
    });
  } catch (error) {
    next(error);
  }
};

export const updateUserRole = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const { userId } = req.params;
    const validatedData = updateUserRoleSchema.parse(req.body);
    const updatedUser = await userService.updateUserRole(
      userId,
      validatedData.role,
      req.user!.id,
    );
    res.json(updatedUser);
  } catch (error) {
    next(error);
  }
};
```

## File: src/middlewares/auth.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { PrismaClient } from ".prisma/client";
import { AppError } from "./errorHandler.middleware";

const prisma = new PrismaClient();

interface JwtPayload {
  userId: string;
  role: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        role: string;
      };
    }
  }
}

export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      throw new AppError(401, "No token provided");
    }

    const token = authHeader.split(" ")[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, role: true, isActive: true },
    });

    if (!user || !user.isActive) {
      throw new AppError(401, "User not found or inactive");
    }

    req.user = {
      id: user.id,
      role: user.role,
    };

    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError(401, "Invalid or expired token"));
    } else {
      next(error);
    }
  }
};

export const authorize = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw new AppError(401, "Not authenticated");
    }

    if (!roles.includes(req.user.role)) {
      throw new AppError(403, "Not authorized to access this resource");
    }

    next();
  };
};
```

## File: src/middlewares/cache.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import redisClient from "../config/redis";
import { logger } from "../utils/logger";

export const cacheMiddleware = (ttl: number) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (req.method !== "GET") {
      return next();
    }

    const key = `cache:${req.originalUrl}`;

    try {
      const data = await redisClient.get(key);
      if (data) {
        return res.json(JSON.parse(data));
      }

      const originalJson = res.json.bind(res);

      res.json = ((data: any) => {
        redisClient
          .setEx(key, ttl, JSON.stringify(data))
          .catch((err) => logger.error("Redis cache error:", err));
        return originalJson(data);
      }) as any;

      next();
    } catch (error) {
      logger.error("Cache middleware error:", error);
      next();
    }
  };
};
```

## File: src/middlewares/errorHandler.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";
import { ZodError } from "zod";
import {
  PrismaClientKnownRequestError,
  PrismaClientValidationError,
} from "@prisma/client/runtime/library";

export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public isOperational = true,
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  logger.error("Error:", err);

  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      message: err.message,
    });
  }

  if (err instanceof ZodError) {
    const errors = err.errors
      .map((e) => `${e.path.join(".")}: ${e.message}`)
      .join(", ");
    return res.status(400).json({
      message: errors,
    });
  }

  if (err instanceof PrismaClientKnownRequestError) {
    let statusCode = 500;
    let message = err.message;
    return res.status(statusCode).json({ message });
  }

  if (err instanceof PrismaClientValidationError) {
    return res.status(400).json({
      message: "Invalid data provided",
    });
  }

  const message =
    process.env.NODE_ENV === "development"
      ? err.message
      : "Internal server error";
  return res.status(500).json({ message });
};
```

## File: src/middlewares/rate-limit.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import redisClient from "../config/redis";
import { logger } from "../utils/logger";

interface RateLimitConfig {
  windowMs: number; // Time window in milliseconds
  max: number; // Max number of requests within the window
  message?: string;
}

export const createRateLimiter = (config: RateLimitConfig) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = `rate-limit:${req.ip}`;

    try {
      const requests = await redisClient.get(key);
      const currentCount = requests ? parseInt(requests) : 0;

      if (currentCount >= config.max) {
        return res.status(429).json({
          status: "error",
          message:
            config.message || "Too many requests, please try again later.",
        });
      }

      if (currentCount === 0) {
        await redisClient.setEx(key, Math.floor(config.windowMs / 1000), "1");
      } else {
        await redisClient.incr(key);
      }

      res.setHeader("X-RateLimit-Limit", config.max);
      res.setHeader("X-RateLimit-Remaining", config.max - (currentCount + 1));

      next();
    } catch (error) {
      logger.error("Rate limiter error:", error);
      next();
    }
  };
};

export const authRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests per 15 minutes
  message:
    "Too many authentication attempts. Please try again after 15 minutes.",
});

export const apiRateLimiter = createRateLimiter({
  windowMs: 60 * 1000, // 1 minute
  max: 60, // 60 requests per minute
  message: "Too many requests. Please try again after a minute.",
});

export const searchRateLimiter = createRateLimiter({
  windowMs: 60 * 1000, // 1 minute
  max: 30, // 30 searches per minute
  message: "Search rate limit exceeded. Please try again after a minute.",
});
```

## File: src/middlewares/request-logger.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const startTime = Date.now();

  logger.info("Incoming Request", {
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userAgent: req.get("user-agent"),
    body: req.method !== "GET" ? req.body : undefined,
    query: Object.keys(req.query).length > 0 ? req.query : undefined,
    params: Object.keys(req.params).length > 0 ? req.params : undefined,
  });

  const originalSend = res.send;
  res.send = function (body) {
    const responseTime = Date.now() - startTime;

    logger.info("Outgoing Response", {
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      responseTime: `${responseTime}ms`,
    });

    return originalSend.call(this, body);
  };

  next();
};
```

## File: src/middlewares/validate.middleware.ts
```typescript
import { Request, Response, NextFunction } from "express";
import { AnyZodObject } from "zod";
import { logger } from "../utils/logger";

export const validateRequest = (schema: AnyZodObject) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error: any) {
      logger.error("Validation error:", error);
      res.status(400).json({
        error: "Validation failed",
        details: error.errors,
      });
    }
  };
};
```

## File: src/models/analytics.schema.ts
```typescript
import { z } from "zod";

export const dateRangeSchema = z
  .object({
    startDate: z
      .string()
      .datetime()
      .default(() =>
        new Date(new Date().setDate(new Date().getDate() - 30)).toISOString(),
      ),
    endDate: z
      .string()
      .datetime()
      .default(() => new Date().toISOString()),
  })
  .refine((data) => new Date(data.startDate) <= new Date(data.endDate), {
    message: "End date must be after start date",
  });

export const analyticsQuerySchema = z.object({
  limit: z.coerce.number().int().positive().default(10),
});

export type DateRangeParams = z.infer<typeof dateRangeSchema>;
export type AnalyticsQueryParams = z.infer<typeof analyticsQuerySchema>;
```

## File: src/models/auth.schema.ts
```typescript
import { z } from "zod";

export const registerSchema = z.object({
  body: z.object({
    email: z.string().email("Invalid email format"),
    password: z
      .string()
      .min(8, "Password must be at least 8 characters")
      .regex(
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
        "Password must contain at least one uppercase letter, one lowercase letter, and one number",
      ),
    firstName: z.string().min(2, "First name must be at least 2 characters"),
    lastName: z.string().min(2, "Last name must be at least 2 characters"),
  }),
});

export const loginSchema = z.object({
  body: z.object({
    email: z.string().email("Invalid email format"),
    password: z.string().min(1, "Password is required"),
  }),
});

export const emailVerificationSchema = z.object({
  token: z.string(),
});

export const passwordResetRequestSchema = z.object({
  email: z.string().email("Invalid email format"),
});

export const passwordResetSchema = z.object({
  token: z.string(),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      "Password must contain at least one uppercase letter, one lowercase letter, and one number",
    ),
});
```

## File: src/models/book.schema.ts
```typescript
import { z } from "zod";

export const createBookSchema = z.object({
  isbn: z.string().min(10, "ISBN must be at least 10 characters"),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  totalCopies: z.number().int().positive(),
  categoryIds: z.array(z.string()).min(1, "At least one category is required"),
  authorIds: z.array(z.string()).min(1, "At least one author is required"),
});

export const updateBookSchema = createBookSchema.partial();

export const deleteBookSchema = z.object({
  isbn: z.string().min(10, "ISBN must be at least 10 characters"),
});

export const searchBooksSchema = z.object({
  query: z.string().optional(),
  category: z.string().optional(),
  author: z.string().optional(),
  available: z.coerce.boolean().optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().default(10),
});

export type CreateBookInput = z.infer<typeof createBookSchema>;
export type UpdateBookInput = z.infer<typeof updateBookSchema>;
export type SearchBooksParams = z.infer<typeof searchBooksSchema>;
```

## File: src/models/borrow.schema.ts
```typescript
import { z } from "zod";

export const borrowBookSchema = z.object({
  bookId: z.string().uuid(),
});

export const borrowQuerySchema = z.object({
  status: z.enum(["active", "returned", "overdue"]).optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().default(10),
});

export type BorrowBookInput = z.infer<typeof borrowBookSchema>;
export type BorrowQueryParams = z.infer<typeof borrowQuerySchema>;
```

## File: src/models/payment.schema.ts
```typescript
import { z } from "zod";

export const paymentMethodSchema = z.enum([
  "CREDIT_CARD",
  "DEBIT_CARD",
  "CASH",
]);
export const paymentStatusSchema = z.enum(["PENDING", "PAID", "FAILED"]);

export const payFineSchema = z.object({
  transactionId: z.string().uuid(),
  paymentMethod: paymentMethodSchema,
});

export const paymentQuerySchema = z.object({
  status: paymentStatusSchema.optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().default(10),
});

export type PayFineInput = z.infer<typeof payFineSchema>;
export type PaymentQueryParams = z.infer<typeof paymentQuerySchema>;
export type PaymentMethod = z.infer<typeof paymentMethodSchema>;
export type PaymentStatus = z.infer<typeof paymentStatusSchema>;
```

## File: src/models/user.schema.ts
```typescript
import { z } from "zod";

export const updateProfileSchema = z
  .object({
    firstName: z.string().min(1, "First name is required").optional(),
    lastName: z.string().min(1, "Last name is required").optional(),
    email: z.string().email("Invalid email format").optional(),
    currentPassword: z
      .string()
      .min(6, "Current password must be at least 6 characters")
      .optional(),
    newPassword: z
      .string()
      .min(6, "New password must be at least 6 characters")
      .optional(),
  })
  .refine(
    (data) => {
      if (data.newPassword && !data.currentPassword) {
        return false;
      }
      return true;
    },
    {
      message: "Current password is required when setting a new password",
    },
  );

export const updateUserRoleSchema = z.object({
  role: z.enum(["ADMIN", "MEMBER"]).default("MEMBER"),
});

export type UpdateProfileInput = z.infer<typeof updateProfileSchema>;
```

## File: src/routes/analytics.routes.ts
```typescript
import { Router } from "express";
import {
  getMostBorrowedBooks,
  getMonthlyReport,
  getOverdueStats,
} from "../controllers/analytics.controller";
import { authenticate, authorize } from "../middlewares/auth.middleware";
import { cacheMiddleware } from "../middlewares/cache.middleware";

const router = Router();

router.use(authenticate, authorize("ADMIN"));

router.get("/most-borrowed", cacheMiddleware(3600), getMostBorrowedBooks);
router.get("/monthly-report", cacheMiddleware(21600), getMonthlyReport);
router.get("/overdue-stats", cacheMiddleware(3600 * 12), getOverdueStats);

export default router;
```

## File: src/routes/auth.routes.ts
```typescript
import { Router } from "express";
import { AuthController } from "../controllers/auth.controller";
import { validateRequest } from "../middlewares/validate.middleware";
import { registerSchema, loginSchema } from "../models/auth.schema";

const router = Router();
const authController = new AuthController();

router.post(
  "/register",
  validateRequest(registerSchema),
  authController.register,
);
router.post("/login", validateRequest(loginSchema), authController.login);
router.get("/verify-email", authController.verifyEmail);
router.post("/resend-verification", authController.resendVerificationEmail);

export default router;
```

## File: src/routes/book.routes.ts
```typescript
import { Router } from "express";
import {
  createBook,
  updateBook,
  deleteBook,
  searchBooks,
  getBookDetails,
} from "../controllers/book.controller";
import { authenticate, authorize } from "../middlewares/auth.middleware";
import { cacheMiddleware } from "../middlewares/cache.middleware";

const router = Router();

router.get("/search", cacheMiddleware(300), searchBooks);
router.get("/:isbn", cacheMiddleware(3600), getBookDetails);

router.use(authenticate);
router.post("/", authorize("ADMIN"), createBook);
router.put("/:isbn", authorize("ADMIN"), updateBook);
router.delete("/:isbn", authorize("ADMIN"), deleteBook);

export default router;
```

## File: src/routes/borrow.routes.ts
```typescript
import { Router } from "express";
import {
  borrowBook,
  returnBook,
  getBorrowingHistory,
} from "../controllers/borrow.controller";
import { authenticate } from "../middlewares/auth.middleware";

const router = Router();

router.use(authenticate);

router.post("/", borrowBook);
router.post("/:isbn/return", returnBook);
router.get("/history", getBorrowingHistory);

export default router;
```

## File: src/routes/payment.routes.ts
```typescript
import { Router } from "express";
import {
  getFines,
  payFine,
  getPaymentHistory,
  generateInvoice,
} from "../controllers/payment.controller";
import { authenticate } from "../middlewares/auth.middleware";

const router = Router();

router.use(authenticate);

router.get("/fines", getFines);
router.post("/fines/pay", payFine);
router.get("/history", getPaymentHistory);
router.get("/invoice/:transactionId", generateInvoice);

export default router;
```

## File: src/routes/user.routes.ts
```typescript
import { Router } from "express";
import { authenticate, authorize } from "../middlewares/auth.middleware";
import {
  getProfile,
  updateProfile,
  deactivateAccount,
  updateUserRole,
} from "../controllers/user.controller";
import { cacheMiddleware } from "../middlewares/cache.middleware";

const router = Router();

router.use(authenticate);

router.get("/profile", cacheMiddleware(900), getProfile);

router.put("/profile", updateProfile);

router.post("/deactivate", deactivateAccount);

router.put("/:userId/role", authorize("ADMIN"), updateUserRole);

export default router;
```

## File: src/services/analytics.service.ts
```typescript
import { prisma } from "../config/db/database";
import type { Book, User, Category } from ".prisma/client";

interface BookAnalytics {
  id: string;
  title: string;
  isbn: string;
  totalCopies: number;
  availableCopies: number;
  borrowCount: number;
  authors: string[];
  categories: string[];
}

interface UserAnalytics {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  borrowCount: number;
}

interface CategoryAnalytics {
  name: string;
  bookCount: number;
  borrowCount: number;
}

export class AnalyticsService {
  async getBookAnalytics(): Promise<BookAnalytics[]> {
    const books = await prisma.book.findMany({
      include: {
        borrowedBooks: true,
        authors: {
          include: {
            author: true,
          },
        },
        categories: {
          include: {
            category: true,
          },
        },
      },
    });

    return books.map(
      (
        book: Book & {
          borrowedBooks: any[];
          authors: { author: { name: string } }[];
          categories: { category: { name: string } }[];
        },
      ) => ({
        id: book.id,
        title: book.title,
        isbn: book.isbn,
        totalCopies: book.totalCopies,
        availableCopies: book.availableCopies,
        borrowCount: book.borrowedBooks.length,
        authors: book.authors.map((a) => a.author.name),
        categories: book.categories.map((c) => c.category.name),
      }),
    );
  }

  async getDashboardStats() {
    const [
      totalBooks,
      totalUsers,
      activeUsers,
      totalBorrows,
      popularCategories,
      overdueBooks,
    ] = await Promise.all([
      prisma.book.count(),
      prisma.user.count(),
      prisma.user.findMany({
        where: {
          borrowedBooks: {
            some: {},
          },
        },
        include: {
          borrowedBooks: true,
        },
      }),
      prisma.borrowedBook.count(),
      prisma.category.findMany({
        include: {
          books: {
            include: {
              book: {
                include: {
                  borrowedBooks: true,
                },
              },
            },
          },
        },
      }),
      prisma.borrowedBook.findMany({
        where: {
          returnedAt: null,
          dueDate: {
            lt: new Date(),
          },
        },
        include: {
          book: true,
          user: true,
        },
      }),
    ]);

    return {
      totalBooks,
      totalUsers,
      totalBorrows,
      activeUsers: activeUsers.map((user: User & { borrowedBooks: any[] }) => ({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        borrowCount: user.borrowedBooks.length,
      })),
      popularCategories: popularCategories.map(
        (
          category: Category & {
            books: {
              book: {
                borrowedBooks: any[];
              };
            }[];
          },
        ) => ({
          name: category.name,
          bookCount: category.books.length,
          borrowCount: category.books.reduce(
            (sum, { book }) => sum + book.borrowedBooks.length,
            0,
          ),
        }),
      ),
      overdue: {
        count: overdueBooks.length,
        totalFinesPending: overdueBooks.reduce((sum: number, book: any) => {
          const daysOverdue = Math.floor(
            (new Date().getTime() - new Date(book.dueDate).getTime()) /
              (1000 * 60 * 60 * 24),
          );
          return sum + daysOverdue * 1;
        }, 0),
        books: overdueBooks.map((book: any) => ({
          id: book.id,
          bookTitle: book.book.title,
          userName: `${book.user.firstName} ${book.user.lastName}`,
          dueDate: book.dueDate,
          daysOverdue: Math.floor(
            (new Date().getTime() - new Date(book.dueDate).getTime()) /
              (1000 * 60 * 60 * 24),
          ),
        })),
      },
    };
  }

  async getMostBorrowedBooks(limit: number = 10) {
    const books = await prisma.book.findMany({
      take: limit,
      include: {
        borrowedBooks: true,
        authors: {
          include: {
            author: true,
          },
        },
        categories: {
          include: {
            category: true,
          },
        },
      },
      orderBy: {
        borrowedBooks: {
          _count: "desc",
        },
      },
    });

    return books.map((book) => ({
      id: book.id,
      title: book.title,
      isbn: book.isbn,
      borrowCount: book.borrowedBooks.length,
      authors: book.authors.map((a) => a.author.name),
      categories: book.categories.map((c) => c.category.name),
    }));
  }

  async getMonthlyReport(startDate: Date, endDate: Date) {
    const [borrowings, returns, newUsers, totalFines] = await Promise.all([
      prisma.borrowedBook.count({
        where: {
          borrowedAt: {
            gte: startDate,
            lte: endDate,
          },
        },
      }),
      prisma.borrowedBook.count({
        where: {
          returnedAt: {
            gte: startDate,
            lte: endDate,
          },
        },
      }),
      prisma.user.count({
        where: {
          createdAt: {
            gte: startDate,
            lte: endDate,
          },
        },
      }),
      prisma.transaction.aggregate({
        where: {
          status: "PAID",
          updatedAt: {
            gte: startDate,
            lte: endDate,
          },
        },
        _sum: {
          amount: true,
        },
      }),
    ]);

    return {
      period: { startDate, endDate },
      statistics: {
        totalBorrowings: borrowings,
        totalReturns: returns,
        newUsers,
        finesCollected: totalFines._sum.amount || 0,
      },
    };
  }

  async getOverdueStats() {
    const overdueBooks = await prisma.borrowedBook.findMany({
      where: {
        returnedAt: null,
        dueDate: {
          lt: new Date(),
        },
      },
      include: {
        book: true,
        user: true,
      },
    });

    return {
      totalOverdue: overdueBooks.length,
      totalFinesPending: overdueBooks.reduce((sum, book) => {
        const daysOverdue = Math.ceil(
          (new Date().getTime() - new Date(book.dueDate).getTime()) /
            (1000 * 60 * 60 * 24),
        );
        return sum + daysOverdue;
      }, 0),
      books: overdueBooks.map((book) => ({
        id: book.id,
        bookTitle: book.book.title,
        borrower: {
          id: book.user.id,
          name: `${book.user.firstName} ${book.user.lastName}`,
          email: book.user.email,
        },
        dueDate: book.dueDate,
        daysOverdue: Math.ceil(
          (new Date().getTime() - new Date(book.dueDate).getTime()) /
            (1000 * 60 * 60 * 24),
        ),
      })),
    };
  }
}
```

## File: src/services/auth.service.ts
```typescript
import { prisma } from "../config/db/database";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import type { User } from ".prisma/client";
import { sendVerificationEmail } from "../utils/email";
import crypto from "crypto";

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
}

export class AuthService {
  async login({ email, password }: LoginCredentials): Promise<{
    token: string;
    user: Omit<User, "password">;
  }> {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) throw new Error("User not found");
    if (!user.isActive) throw new Error("User account is deactivated");
    if (!user.isEmailVerified)
      throw new Error("Please verify your email before logging in");

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) throw new Error("Invalid password");

    const token = jwt.sign(
      { userId: user.id, role: user.role },
      process.env.JWT_SECRET || "your-jwt-secret-key",
      { expiresIn: process.env.JWT_EXPIRES_IN || "1d" },
    );

    const { password: _, ...userWithoutPassword } = user;
    return { token, user: userWithoutPassword };
  }

  async register(data: RegisterData): Promise<Omit<User, "password">> {
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new Error("Email already registered");
    }

    const hashedPassword = await bcrypt.hash(data.password, 10);

    const user = await prisma.user.create({
      data: {
        ...data,
        password: hashedPassword,
      },
    });

    const verificationToken = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);

    await prisma.emailVerificationToken.create({
      data: {
        token: verificationToken,
        userId: user.id,
        expiresAt,
      },
    });

    await sendVerificationEmail(user.email, verificationToken);

    const { password: _, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  async verifyEmail(token: string): Promise<void> {
    const verificationToken = await prisma.emailVerificationToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!verificationToken) {
      throw new Error("Invalid verification token");
    }

    if (verificationToken.expiresAt < new Date()) {
      throw new Error("Verification token has expired");
    }
    await prisma.$transaction([
      prisma.user.update({
        where: { id: verificationToken.userId },
        data: { isEmailVerified: true },
      }),
      prisma.emailVerificationToken.delete({
        where: { id: verificationToken.id },
      }),
    ]);
  }

  async resendVerificationEmail(email: string): Promise<void> {
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      throw new Error("User not found");
    }

    if (user.isEmailVerified) {
      throw new Error("Email is already verified");
    }

    await prisma.emailVerificationToken.deleteMany({
      where: { userId: user.id },
    });

    const verificationToken = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);

    await prisma.emailVerificationToken.create({
      data: {
        token: verificationToken,
        userId: user.id,
        expiresAt,
      },
    });

    await sendVerificationEmail(user.email, verificationToken);
  }

  async resetPassword(userId: string, newPassword: string): Promise<void> {
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await prisma.user.update({
      where: { id: userId },
      data: { password: hashedPassword },
    });
  }
}
```

## File: src/services/book.service.ts
```typescript
import { prisma } from "../config/db/database";
import type { Book, Prisma } from ".prisma/client";

interface CreateBookInput {
  isbn: string;
  title: string;
  description?: string;
  totalCopies: number;
  authorIds: string[];
  categoryIds: string[];
}

interface UpdateBookInput {
  title?: string;
  description?: string;
  totalCopies?: number;
  authorIds?: string[];
  categoryIds?: string[];
}

export class BookService {
  async createBook(data: CreateBookInput): Promise<Book> {
    const existingBook = await prisma.book.findUnique({
      where: { isbn: data.isbn },
    });

    if (existingBook) {
      throw new Error("Book with this ISBN already exists");
    }

    return prisma.book.create({
      data: {
        isbn: data.isbn,
        title: data.title,
        description: data.description,
        totalCopies: data.totalCopies,
        availableCopies: data.totalCopies,
        authors: {
          create: data.authorIds.map((authorId) => ({
            author: {
              connect: { id: authorId },
            },
          })),
        },
        categories: {
          create: data.categoryIds.map((categoryId) => ({
            category: {
              connect: { id: categoryId },
            },
          })),
        },
      },
      include: {
        authors: {
          include: {
            author: true,
          },
        },
        categories: {
          include: {
            category: true,
          },
        },
      },
    });
  }

  async updateBook(id: string, data: UpdateBookInput): Promise<Book> {
    const book = await prisma.book.findUnique({
      where: { isbn: id },
      include: {
        authors: true,
        categories: true,
      },
    });

    if (!book) {
      throw new Error("Book not found");
    }

    if (data.authorIds) {
      await prisma.authorsOnBooks.deleteMany({
        where: { bookId: id },
      });
    }

    if (data.categoryIds) {
      await prisma.categoriesOnBooks.deleteMany({
        where: { bookId: id },
      });
    }

    return prisma.book.update({
      where: { id },
      data: {
        title: data.title,
        description: data.description,
        totalCopies: data.totalCopies,
        availableCopies: data.totalCopies,
        authors: data.authorIds
          ? {
              create: data.authorIds.map((authorId) => ({
                author: {
                  connect: { id: authorId },
                },
              })),
            }
          : undefined,
        categories: data.categoryIds
          ? {
              create: data.categoryIds.map((categoryId) => ({
                category: {
                  connect: { id: categoryId },
                },
              })),
            }
          : undefined,
      },
      include: {
        authors: {
          include: {
            author: true,
          },
        },
        categories: {
          include: {
            category: true,
          },
        },
      },
    });
  }

  async deleteBook(id: string): Promise<void> {
    const book = await prisma.book.findUnique({
      where: { id },
      include: {
        borrowedBooks: {
          where: {
            returnedAt: null,
          },
        },
      },
    });

    if (!book) {
      throw new Error("Book not found");
    }

    if (book.borrowedBooks.length > 0) {
      throw new Error("Cannot delete book with active borrowings");
    }

    await prisma.book.delete({
      where: { id },
    });
  }

  async findBookById(isbn: string) {
    return prisma.book.findUnique({
      where: { isbn },
      include: {
        authors: {
          include: {
            author: {
              select: {
                id: true,
                name: true,
                bio: true,
              },
            },
          },
        },
        categories: {
          include: {
            category: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
      },
    });
  }

  async findBooks(params: {
    search?: string;
    categoryIds?: string[];
    authorIds?: string[];
    available?: boolean;
    skip?: number;
    take?: number;
  }): Promise<{ books: Partial<Book>[]; total: number }> {
    const where: Prisma.BookWhereInput = {
      OR: params.search
        ? [
            { title: { contains: params.search, mode: "insensitive" } },
            { isbn: { contains: params.search, mode: "insensitive" } },
          ]
        : undefined,
      categories: params.categoryIds
        ? {
            some: {
              categoryId: {
                in: params.categoryIds,
              },
            },
          }
        : undefined,
      authors: params.authorIds
        ? {
            some: {
              authorId: {
                in: params.authorIds,
              },
            },
          }
        : undefined,
      availableCopies: params.available ? { gt: 0 } : undefined,
    };

    const [books, total] = await Promise.all([
      prisma.book.findMany({
        where,
        skip: params.skip,
        take: params.take,
        select: {
          isbn: true,
          title: true,
          description: true,
          availableCopies: true,
          authors: {
            select: {
              author: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
        },
        orderBy: {
          title: "asc",
        },
      }),
      prisma.book.count({ where }),
    ]);

    return {
      books: books.map((book) => ({
        ...book,
        authors: book.authors.map((a) => ({
          id: a.author.id,
          name: a.author.name,
        })),
        categories: book.categories.map((c) => ({
          id: c.category.id,
          name: c.category.name,
        })),
      })),
      total,
    };
  }
}
```

## File: src/services/borrow.service.ts
```typescript
import { prisma } from "../config/db/database";
import type { BorrowedBook, Prisma } from ".prisma/client";
import { sendBookDueReminderEmail } from "../utils/email";

export class BorrowService {
  private BORROW_DURATION_DAYS = 14;
  private FINE_RATE_PER_DAY = 1.0;

  async borrowBook(userId: string, bookId: string): Promise<BorrowedBook> {
    const book = await prisma.book.findUnique({
      where: { id: bookId },
      include: {
        borrowedBooks: {
          where: {
            userId,
            returnedAt: null,
          },
        },
      },
    });

    if (!book) {
      throw new Error("Book not found");
    }

    if (book.availableCopies <= 0) {
      throw new Error("No copies available for borrowing");
    }

    if (book.borrowedBooks.length > 0) {
      throw new Error("User already has an active borrow for this book");
    }

    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + this.BORROW_DURATION_DAYS);

    return prisma.$transaction(async (tx) => {
      await tx.book.update({
        where: { id: bookId },
        data: {
          availableCopies: {
            decrement: 1,
          },
        },
      });

      return tx.borrowedBook.create({
        data: {
          userId,
          bookId,
          dueDate,
        },
        include: {
          book: true,
          user: true,
        },
      });
    });
  }

  calculateFine(borrowedBook: BorrowedBook): number {
    if (!borrowedBook.dueDate || borrowedBook.returnedAt) {
      return 0;
    }

    const currentDate = new Date();
    const dueDate = new Date(borrowedBook.dueDate);

    if (currentDate <= dueDate) {
      return 0;
    }

    const overdueDays = Math.floor(
      (currentDate.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24),
    );
    return overdueDays * this.FINE_RATE_PER_DAY;
  }

  async returnBook(userId: string, bookId: string): Promise<BorrowedBook> {
    const borrowedBook = await prisma.borrowedBook.findFirst({
      where: {
        userId,
        bookId,
        returnedAt: null,
      },
    });

    if (!borrowedBook) {
      throw new Error("No active borrow found for this book");
    }

    const fine = this.calculateFine(borrowedBook);

    return prisma.$transaction(async (tx) => {
      await tx.book.update({
        where: { id: bookId },
        data: {
          availableCopies: {
            increment: 1,
          },
        },
      });

      const updatedBorrow = await tx.borrowedBook.update({
        where: { id: borrowedBook.id },
        data: {
          returnedAt: new Date(),
        },
        include: {
          book: true,
          user: true,
        },
      });

      if (fine > 0) {
        await tx.transaction.create({
          data: {
            userId,
            borrowedBookId: borrowedBook.id,
            amount: fine,
            status: "PENDING",
          },
        });
      }

      return updatedBorrow;
    });
  }

  async getUserBorrows(
    userId: string,
    params: {
      status?: "active" | "returned" | "overdue";
      skip?: number;
      take?: number;
    },
  ): Promise<{ borrows: BorrowedBook[]; total: number }> {
    const where: Prisma.BorrowedBookWhereInput = {
      userId,
      ...(params.status === "active" && {
        returnedAt: null,
        dueDate: {
          gt: new Date(),
        },
      }),
      ...(params.status === "returned" && {
        returnedAt: {
          not: null,
        },
      }),
      ...(params.status === "overdue" && {
        returnedAt: null,
        dueDate: {
          lt: new Date(),
        },
      }),
    };

    const [borrows, total] = await Promise.all([
      prisma.borrowedBook.findMany({
        where,
        skip: params.skip,
        take: params.take,
        include: {
          book: true,
          user: true,
        },
        orderBy: {
          borrowedAt: "desc",
        },
      }),
      prisma.borrowedBook.count({ where }),
    ]);

    return { borrows, total };
  }

  async getBookBorrows(
    bookId: string,
    params: {
      status?: "active" | "returned" | "overdue";
      skip?: number;
      take?: number;
    },
  ): Promise<{ borrows: BorrowedBook[]; total: number }> {
    const where: Prisma.BorrowedBookWhereInput = {
      bookId,
      ...(params.status === "active" && {
        returnedAt: null,
        dueDate: {
          gt: new Date(),
        },
      }),
      ...(params.status === "returned" && {
        returnedAt: {
          not: null,
        },
      }),
      ...(params.status === "overdue" && {
        returnedAt: null,
        dueDate: {
          lt: new Date(),
        },
      }),
    };

    const [borrows, total] = await Promise.all([
      prisma.borrowedBook.findMany({
        where,
        skip: params.skip,
        take: params.take,
        include: {
          book: true,
          user: true,
        },
        orderBy: {
          borrowedAt: "desc",
        },
      }),
      prisma.borrowedBook.count({ where }),
    ]);

    return { borrows, total };
  }

  async sendDueReminders(): Promise<number> {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);

    const dayAfterTomorrow = new Date(tomorrow);
    dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);

    const dueBorrowings = await prisma.borrowedBook.findMany({
      where: {
        returnedAt: null,
        dueDate: {
          gte: tomorrow,
          lt: dayAfterTomorrow,
        },
      },
      include: {
        user: true,
        book: true,
      },
    });

    await Promise.all(
      dueBorrowings.map(async (borrowing) => {
        await sendBookDueReminderEmail(
          borrowing.user.email,
          borrowing.book.title,
          borrowing.dueDate,
        );
      }),
    );

    return dueBorrowings.length;
  }
}
```

## File: src/services/payment.service.ts
```typescript
import { prisma } from "../config/db/database";
import { AppError } from "../middlewares/errorHandler.middleware";
import type { PaymentStatus } from ".prisma/client";

export type PaymentMethod = "CREDIT_CARD" | "DEBIT_CARD" | "CASH";

export class PaymentService {
  async getFines(userId: string) {
    const fines = await prisma.transaction.findMany({
      where: {
        userId,
        status: "PENDING",
      },
      include: {
        borrowedBook: {
          include: {
            book: true,
          },
        },
      },
    });

    const total = fines.reduce((sum, fine) => sum + fine.amount, 0);

    return { fines, total };
  }

  async payFine(
    userId: string,
    transactionId: string,
    paymentMethod: PaymentMethod,
  ) {
    return prisma.$transaction(async (tx) => {
      const fine = await tx.transaction.findFirst({
        where: {
          id: transactionId,
          userId,
          status: "PENDING",
        },
      });

      if (!fine) {
        throw new AppError(404, "Fine not found or already paid");
      }

      const updatedFine = await tx.transaction.update({
        where: { id: fine.id },
        data: {
          status: "PAID",
          updatedAt: new Date(),
        },
      });

      return updatedFine;
    });
  }

  async getPaymentHistory(userId: string, status?: PaymentStatus) {
    const whereClause = {
      userId,
      ...(status && { status }),
    };

    const payments = await prisma.transaction.findMany({
      where: whereClause,
      include: {
        borrowedBook: {
          include: {
            book: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    const total = payments.reduce((sum, payment) => sum + payment.amount, 0);

    return { payments, total };
  }

  async generateInvoice(userId: string, transactionId: string) {
    const transaction = await prisma.transaction.findFirst({
      where: {
        id: transactionId,
        userId,
      },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        borrowedBook: {
          include: {
            book: true,
          },
        },
      },
    });

    if (!transaction) {
      throw new AppError(404, "Transaction not found");
    }

    return {
      invoiceNumber: `INV-${transaction.id.slice(0, 8).toUpperCase()}`,
      date: transaction.createdAt,
      status: transaction.status,
      customer: {
        name: `${transaction.user.firstName} ${transaction.user.lastName}`,
        email: transaction.user.email,
      },
      book: {
        title: transaction.borrowedBook.book.title,
        isbn: transaction.borrowedBook.book.isbn,
      },
      borrowing: {
        borrowedAt: transaction.borrowedBook.borrowedAt,
        dueDate: transaction.borrowedBook.dueDate,
        returnedAt: transaction.borrowedBook.returnedAt,
      },
      amount: transaction.amount,
      currency: "USD",
    };
  }
}
```

## File: src/services/scheduler.service.ts
```typescript
import { CronJob } from "cron";
import { BorrowService } from "./borrow.service";
import { logger } from "../utils/logger";

export class SchedulerService {
  private borrowService: BorrowService;
  private reminderJob: CronJob;

  constructor() {
    this.borrowService = new BorrowService();

    this.reminderJob = new CronJob("0 0 * * *", async () => {
      try {
        const remindersSent = await this.borrowService.sendDueReminders();
        logger.info(`Sent ${remindersSent} due date reminders`);
      } catch (error) {
        logger.error("Error sending due date reminders:", error);
      }
    });
  }

  startJobs() {
    this.reminderJob.start();
    logger.info("Scheduler jobs started");
  }

  stopJobs() {
    this.reminderJob.stop();
    logger.info("Scheduler jobs stopped");
  }
}
```

## File: src/services/user.service.ts
```typescript
import { prisma } from "../config/db/database";
import { AppError } from "../middlewares/errorHandler.middleware";
import bcrypt from "bcryptjs";
import { UserRole } from "@prisma/client";

interface UpdateProfileInput {
  firstName?: string;
  lastName?: string;
  email?: string;
  currentPassword?: string;
  newPassword?: string;
}

export class UserService {
  async getProfile(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        isActive: true,
        isEmailVerified: true,
        createdAt: true,
        _count: {
          select: {
            borrowedBooks: true,
          },
        },
      },
    });

    if (!user) {
      throw new AppError(404, "User not found");
    }

    return user;
  }

  async updateProfile(userId: string, data: UpdateProfileInput) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new AppError(404, "User not found");
    }

    if (data.newPassword) {
      if (!data.currentPassword) {
        throw new AppError(
          400,
          "Current password is required to set new password",
        );
      }

      const isPasswordValid = await bcrypt.compare(
        data.currentPassword,
        user.password,
      );
      if (!isPasswordValid) {
        throw new AppError(401, "Current password is incorrect");
      }

      data.newPassword = await bcrypt.hash(data.newPassword, 10);
    }

    if (data.email && data.email !== user.email) {
      const existingUser = await prisma.user.findUnique({
        where: { email: data.email },
      });

      if (existingUser) {
        throw new AppError(409, "Email already in use");
      }
    }

    return prisma.user.update({
      where: { id: userId },
      data: {
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        ...(data.newPassword && { password: data.newPassword }),
        ...(data.email && { isEmailVerified: false }),
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        isActive: true,
        isEmailVerified: true,
        createdAt: true,
      },
    });
  }

  async deactivateAccount(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        borrowedBooks: {
          where: {
            returnedAt: null,
          },
        },
      },
    });

    if (!user) {
      throw new AppError(404, "User not found");
    }

    if (user.borrowedBooks.length > 0) {
      throw new AppError(
        400,
        "Cannot deactivate account while having borrowed books",
      );
    }

    return prisma.user.update({
      where: { id: userId },
      data: {
        isActive: false,
      },
    });
  }

  async updateUserRole(userId: string, newRole: UserRole, adminId: string) {
    const admin = await prisma.user.findUnique({
      where: { id: adminId },
    });

    if (!admin || admin.role !== "ADMIN") {
      throw new AppError(403, "Only administrators can change user roles");
    }

    const targetUser = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!targetUser) {
      throw new AppError(404, "User not found");
    }

    return prisma.user.update({
      where: { id: userId },
      data: { role: newRole },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        isActive: true,
        isEmailVerified: true,
        createdAt: true,
      },
    });
  }
}
```

## File: src/utils/email.ts
```typescript
import { logger } from "./logger";
import { Resend } from "resend";

const RESEND_API_KEY = process.env.RESEND_API_KEY;

const resend = new Resend(RESEND_API_KEY);

export const sendVerificationEmail = async (to: string, token: string) => {
  try {
    const verificationLink = `${process.env.APP_URL}/auth/verify-email?token=${token}`;

    const { data, error } = await resend.emails.send({
      from: "Acme <onboarding@resend.dev>",
      to,
      subject: "Verify Your Email - Library Management System",
      html: `
        <h1>Email Verification</h1>
        <p>Thank you for registering with our Library Management System.</p>
        <p>Please click the link below to verify your email address:</p>
        <a href="${verificationLink}">${verificationLink}</a>
        <p>This link will expire in 24 hours.</p>
        <p>If you did not request this verification, please ignore this email.</p>
      `,
    });
    if (error) {
      logger.error(`Error from resend API: ${error}`);
      throw new Error("Failed to send verification email");
    }
    logger.info(`Verification email sent to ${to}`);
  } catch (error) {
    logger.error("Error sending verification email:", error);
    throw new Error("Failed to send verification email");
  }
};

export const sendPasswordResetEmail = async (to: string, token: string) => {
  try {
    const resetLink = `${process.env.APP_URL}/reset-password?token=${token}`;

    const { data, error } = await resend.emails.send({
      from: "Acme <onboarding@resend.dev>",
      to,
      subject: "Password Reset - Library Management System",
      html: `
      <h1>Password Reset Request</h1>
      <p>You have requested to reset your password.</p>
      <p>Please click the link below to reset your password:</p>
      <a href="${resetLink}">${resetLink}</a>
      <p>This link will expire in 1 hour.</p>
      <p>If you did not request this reset, please ignore this email.</p>
    `,
    });
    if (error) {
      logger.error(`Error from resend API: ${error}`);
      throw new Error("Failed to send verification email");
    }
    logger.info(`Password reset email sent to ${to}`);
  } catch (error) {
    logger.error("Error sending password reset email:", error);
    throw new Error("Failed to send password reset email");
  }
};

export const sendBookDueReminderEmail = async (
  to: string,
  bookTitle: string,
  dueDate: Date,
) => {
  try {
    const { data, error } = await resend.emails.send({
      from: "Acme <onboarding@resend.dev>",
      to,
      subject: "Book Due Reminder - Library Management System",
      html: `
      <h1>Book Due Reminder</h1>
      <p>This is a reminder that your book "${bookTitle}" is due on ${dueDate.toLocaleDateString()}.</p>
      <p>Please return the book to avoid any late fees.</p>
      <p>If you have already returned the book, please ignore this email.</p>
    `,
    });
    if (error) {
      logger.error(`Error from resend API: ${error}`);
      throw new Error("Failed to send verification email");
    }

    logger.info(`Book due reminder email sent to ${to}`);
  } catch (error) {
    logger.error("Error sending book due reminder email:", error);
    throw new Error("Failed to send book due reminder email");
  }
};
```

## File: src/utils/logger.ts
```typescript
import winston from "winston";

const logger = winston.createLogger({
  level: process.env.NODE_ENV === "production" ? "info" : "debug",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json(),
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple(),
      ),
    }),
    new winston.transports.File({ filename: "error.log", level: "error" }),
    new winston.transports.File({ filename: "combined.log" }),
  ],
});

export { logger };
```

## File: src/index.ts
```typescript
import express from "express";
import cors from "cors";
import helmet from "helmet";
import swaggerUi from "swagger-ui-express";
import YAML from "yamljs";
import path from "path";
import { db } from "./config/db/database";
import { apiRateLimiter } from "./middlewares/rate-limit.middleware";
import redisClient from "./config/redis";
import { requestLogger } from "./middlewares/request-logger.middleware";
import { errorHandler } from "./middlewares/errorHandler.middleware";

import authRoutes from "./routes/auth.routes";
import bookRoutes from "./routes/book.routes";
import userRoutes from "./routes/user.routes";
import borrowRoutes from "./routes/borrow.routes";
import analyticsRoutes from "./routes/analytics.routes";
import paymentRoutes from "./routes/payment.routes";

const swaggerDocument = YAML.load(path.join(__dirname, "../openapi.yaml"));

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use(requestLogger);
app.use("/api", apiRateLimiter);

app.get("/", (req, res) => {
  res.send("healthy");
});

app.use("/docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.use("/api/auth", authRoutes);
app.use("/api/books", bookRoutes);
app.use("/api/user", userRoutes);
app.use("/api/borrow", borrowRoutes);
app.use("/api/analytics", analyticsRoutes);
app.use("/api/payments", paymentRoutes);

app.use(errorHandler);

const startServer = async () => {
  try {
    await db.connect();
    await redisClient.connect();

    app.listen(port, () => {
      console.log(` Server is running on port ${port}`);
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
};

process.on("SIGTERM", async () => {
  console.log("SIGTERM received. Shutting down gracefully...");
  await redisClient.quit();
  await db.disconnect();
  process.exit(0);
});

process.on("SIGINT", async () => {
  console.log("SIGINT received. Shutting down gracefully...");
  await redisClient.quit();
  await db.disconnect();
  process.exit(0);
});

startServer();
```

## File: .dockerignore
```
# Dependencies
node_modules
npm-debug.log
yarn-debug.log
yarn-error.log

# Environment

!.env.example

# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp
*.swo

# Build
dist
build
coverage

# Logs
logs
*.log

# System Files
.DS_Store
Thumbs.db

# Docker
Dockerfile
docker-compose.yml
.dockerignore

# Tests
__tests__
*.test.ts
*.spec.ts

# Misc
README.md
LICENSE
*.md
```

## File: .env.example
```
# Database
DATABASE_URL="postgresql://user:password@postgres:5432/library_db?schema=public"

# JWT
JWT_SECRET="your-jwt-secret"
JWT_EXPIRES_IN="1d"

# Email
RESEND_API_KEY="your-api-key"

# Redis
REDIS_URL="redis://redis:6379"

# App
PORT=3000
NODE_ENV="development"
```

## File: .gitignore
```
# Node.js
node_modules/
dist/
scripts/
# TypeScript
*.tsbuildinfo

.env

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDEs and editors
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


repomix-output.txt

# Miscellaneous
.DS_Store
Thumbs.db
```

## File: docker-compose.yml
```yaml
version: "3.8"

services:
  postgres:
    image: postgres:latest
    container_name: library_postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - library_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  redis:
    image: redis:latest
    container_name: library_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - library_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    command: redis-server --appendonly yes

  uptut:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: uptut
    ports:
      - "3000:3000"
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - PORT=3000
      - JWT_SECRET=${JWT_SECRET}
      - RESEND_API_KEY=${RESEND_API_KEY}
      - APP_URL=${APP_URL}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - library_network
    restart: unless-stopped

networks:
  library_network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
```

## File: Dockerfile
```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

RUN apk add --no-cache openssl

COPY package*.json ./
RUN npm install

COPY . .
COPY openapi.yaml ./


COPY src/config/db/prisma/schema.prisma ./src/config/db/prisma/schema.prisma

RUN npx prisma generate --schema=src/config/db/prisma/schema.prisma
RUN npm run build

FROM node:18-alpine AS production

WORKDIR /app

RUN apk add --no-cache openssl

COPY package*.json ./
RUN npm install --only=production

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
COPY --from=builder /app/node_modules/@prisma ./node_modules/@prisma
COPY --from=builder /app/openapi.yaml ./
COPY src/config/db/prisma/ ./dist/config/db/prisma

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

CMD [ "npm" ,"start"]
```

## File: package.json
```json
{
  "name": "library-management-system",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "start": "npm run db:setup-prod && node dist/index.js",
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "test": "jest",
    "lint": "eslint . --ext .ts",
    "prisma:generate": "npx prisma generate --schema=src/config/db/prisma/schema.prisma",
    "prisma:migrate": "npx prisma migrate dev --schema=src/config/db/prisma/schema.prisma",
    "db:seed": "ts-node prisma/seed.ts",
    "db:reset": "npx prisma migrate reset --force --schema=src/config/db/prisma/schema.prisma",
    "db:setup": "npm run prisma:generate && npm run prisma:migrate && npm run db:seed",
    "prisma:generate-prod": "npx prisma generate --schema=dist/config/db/prisma/schema.prisma",
    "prisma:migrate-prod": "npx prisma migrate deploy --schema=dist/config/db/prisma/schema.prisma",
    "db:seed-prod": "node dist/config/db/prisma/seed.js",
    "db:setup-prod": "npm run prisma:migrate-prod && npm run prisma:generate-prod && npm run db:seed-prod",
    "studio": "npx prisma studio --schema=src/config/db/prisma/schema.prisma"
  },
  "keywords": [
    "library",
    "management",
    "system"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@prisma/client": "^5.7.1",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "cron": "^3.3.2",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "form-data": "^4.0.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "prisma": "^5.7.1",
    "redis": "^4.6.11",
    "resend": "^4.0.1",
    "swagger-ui-express": "^5.0.1",
    "winston": "^3.11.0",
    "yamljs": "^0.3.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.11",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20.10.6",
    "@types/nodemailer": "^6.4.14",
    "@types/swagger-ui-express": "^4.1.7",
    "@types/yamljs": "^0.2.34",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "prettier": "^3.4.2",
    "prisma": "^5.7.1",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  },
  "prisma": {
    "schema": "${PRISMA_SCHEMA:-src/config/db/prisma/schema.prisma}",
    "seed": "ts-node src/config/db/prisma/seed.ts"
  }
}
```

## File: README.md
```markdown
# Library Management System

A robust backend system for managing a library's books, users, and borrowing activities.

Swagger Docs: https://uptut.onrender.com/docs/

## Features

- User Authentication with JWT
- Role-based Access Control (Admin/Member)
- Book Management
- Borrowing System
- Fine Management
- Email Notifications
- Analytics and Reports

## Tech Stack

- Node.js
- TypeScript
- Express
- PostgreSQL
- Prisma ORM
- Redis
- Docker

## Project Structure

```
/src
  /config        # Prisma & Redis Configuration files
  /controllers   # Request handlers
  /middlewares   # Express middlewares
  /models        # Database models (Prisma schema)
  /routes        # API routes
  /services      # Business logic
  /utils         # Utility functions
```

## Prerequisites

- Docker and Docker Compose
- Node.js 18 or higher
- npm or yarn

## Setup and Running

1. Clone the repository:

```bash
git clone https://github.com/MuneerAhmed03/uptut.git
cd uptut
```

2. Copy the example environment file:

```bash
cp .env.example .env
```

### Using Docker

3. Start the application using Docker:

```bash
docker-compose up
```

### Without Docker

## Development

To run the application in development mode:

```bash
npm install
npm run db:setup
npm run dev
```

The application will be available at `http://localhost:3000`.

# Detailed System Design for Library Management System

## Overview

This section outlines the design of a Library Management System (LMS) that supports essential library functions such as user management, book cataloging, borrowing, payments, and analytics. The system is modular, scalable, and follows modern software design principles.

---

## Architecture

### System Components

1. **Frontend**: User interface to interact with the system (e.g., web application).
2. **Backend**: RESTful API to handle business logic and data management.
3. **Database**: Persistent storage for structured data using PostgreSQL.
4. **Cache**: Redis for caching frequently accessed data.
5. **Authentication**: JWT-based authentication for secure user sessions.

### Tech Stack

- **Programming Language**: TypeScript
- **Framework**: Express.js
- **Database ORM**: Prisma
- **Cache**: Redis
- **Containerization**: Docker

---

## Database Design

### Entities

1. **User**

2. **Book**

3. **Author**

4. **Category**

5. **BorrowedBook**

6. **Transaction**

### Relationships

- **AuthorsOnBooks**: Many-to-many relationship between `Author` and `Book`.
- **CategoriesOnBooks**: Many-to-many relationship between `Category` and `Book`.
- **Foreign Keys**:
  - `BorrowedBook.userId` references `User.id`
  - `BorrowedBook.bookId` references `Book.id`
  - `Transaction.userId` references `User.id`
  - `Transaction.borrowedBookId` references `BorrowedBook.id`

---

## API Design

### Authentication

1. **Register** (`POST /auth/register`): Registers a new user.
2. **Login** (`POST /auth/login`): Authenticates a user.
3. **Email Verification** (`GET /auth/verify-email`): Verifies user email.

### Book Management

1. **Search Books** (`GET /books/search`): Searches books with filters.
2. **Get Book Details** (`GET /books/:isbn`): Retrieves book details.
3. **Create Book** (`POST /books`): Adds a new book (Admin only).
4. **Update Book** (`PUT /books/:isbn`): Updates book details (Admin only).
5. **Delete Book** (`DELETE /books/:isbn`): Deletes a book (Admin only).

### Borrowing

1. **Borrow Book** (`POST /borrow`): Borrows a book.
2. **Return Book** (`POST /borrow/:isbn/return`): Returns a borrowed book.
3. **Borrowing History** (`GET /borrow/history`): Retrieves borrowing history.

### Payments

1. **Get Fines** (`GET /payment/fines`): Retrieves outstanding fines.
2. **Pay Fine** (`POST /payment/fines/pay`): Pays a fine.
3. **Payment History** (`GET /payment/history`): Fetches payment history.

### Analytics (Admin Only)

1. **Most Borrowed Books** (`GET /analytics/most-borrowed`)
2. **Monthly Report** (`GET /analytics/monthly-report`)
3. **Overdue Stats** (`GET /analytics/overdue-stats`)

---

## Middleware Design

1. **Authentication Middleware**: Ensures the user is authenticated.
2. **Authorization Middleware**: Checks user roles for resource access.
3. **Cache Middleware**: Reduces load on the database for read-heavy endpoints.
4. **Rate Limiting Middleware**: Controls API usage to prevent abuse.
5. **Error Handling Middleware**: Standardized error handling across APIs.
6. **Validation Middleware**: Validates incoming request payloads.

---

## Key Features

### Caching

- **Why**: Improves performance by reducing database calls.
- **Implementation**: Redis is used to store query results for frequently accessed endpoints.

### Scalability

- Designed with modularity to allow for scaling both horizontally and vertically.
- Utilizes Docker for environment standardization and easy deployment.

### Security

1. **Authentication**: Implements JWT for secure user sessions.
2. **Encryption**: Uses bcrypt for password hashing.
3. **Role-based Access Control**: Restricts access to resources based on roles.

### Monitoring

- **Request Logging**: Logs request details for debugging and analytics.
- **Error Logging**: Captures errors in a structured format.

---

## Deployment

### Environment Variables

- `DATABASE_URL`: Database connection string.
- `REDIS_URL`: Redis connection string.
- `JWT_SECRET`: Secret key for JWT.
- `RESEND_API_KEY`: Resend Api Key for emails.

### Steps

1. **Build**: Use Docker to create images.
2. **Deploy**: Push to a container orchestration platform (e.g., Kubernetes).
3. **Seed Data**: Use provided scripts to seed the database.

---
```

## File: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```
